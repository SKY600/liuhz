WEB 攻击方式

# 一、定义

Web攻击（WebAttack）是针对用户上网行为或网站服务器等设备进行攻击的行为。如植入恶意代码，修改网站权限，获取网站用户隐私信息等等。

站点安全就是为保护站点不受未授权的访问、使用、修改和破坏而采取的行为或实践。

# 二、常见方式

## XSS (Cross Site Scripting) 跨站脚本攻击
允许攻击者将恶意代码植入到提供给其它用户使用的页面中。XSS涉及到三方，即攻击者、客户端与Web应用。
### 类型：存储型xss攻击、反射型xss攻击、DOM型xss攻击
#### 存储型xss攻击
1. 攻击者将恶意代码提交到目标网站的数据库中
2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作
>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等

#### 反射型xss攻击
1. 攻击者构造出特殊的 URL，其中包含恶意代码（多作为参数）
2. 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作
>反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。

>反射型 XSS 跟存储型 XSS 的区别是：
**存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。**

由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。
POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见

#### DOM型xss攻击

1. 攻击者构造出特殊的 URL，其中包含恶意代码
2. 用户打开带有恶意代码的 URL
3. 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作

>DOM 型 XSS 跟前两种 XSS 的区别：
**DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。**

### XSS 防御
XSS攻击其实就是代码的注入。用户的输入被编译成恶意的程序代码。
所以，为了防范这一类代码的注入，需要确保用户输入的安全性。
对于攻击验证，我们可以采用以下两种措施：
1. 编码，就是转义用户的输入，把用户的输入解读为数据而不是代码
2. 校验，对用户的输入及请求都进行过滤检查，如对特殊字符进行过滤，设置输入域的匹配规则等。
   
具体比如：
1. 对于验证输入，我们既可以在服务端验证，也可以在客户端验证
2. 对于持久性和反射型攻击，服务端验证是必须的，服务端支持的任何语言都能够做到
3. 对于基于DOM的XSS攻击，验证输入在客户端必须执行，因为从服务端来说，所有发出的页面内容是正常的，只是在客户端js代码执行的过程中才发生可攻击
4. 但是对于各种攻击方式，我们最好做到客户端和服务端都进行处理。

其它还有一些辅助措施，比如：
入参长度限制： 通过以上的案例我们不难发现xss攻击要能达成往往需要较长的字符串，因此对于一些可以预期的输入可以通过限制长度强制截断来进行防御。

```
对危险字符进行转义，比如：
1、空格换成加号(+)
2、正斜杠(/)分隔目录和子目录
3、问号(?)分隔URL和查询
4、百分号(%)制定特殊字符
5、#号指定书签
6、&号分隔参数

辅助理解：
我们在用户输入的过程中，过滤掉用户输入的恶劣代码，然后提交给后端，但是如果攻击者绕开前端请求，直接构造请求就不能预防了。而如果在后端写入数据库前，对输入进行过滤，然后把内容给前端，但是这个内容在不同地方就会有不同显示
例如：
一个正常的用户输入了 5 < 7 这个内容，在写入数据库前，被转义，变成了 5 < 7。在客户端中，一旦经过了 escapeHTML()，客户端显示的内容就变成了乱码( 5 < 7 )。在前端中，不同的位置所需的编码也不同。

当 5 < 7 作为 HTML 拼接页面时，可以正常显示：```<div title="comment">5 &lt; 7</div>```
当 5 < 7 通过 Ajax 返回，然后赋值给 JavaScript 的变量时，前端得到的字符串就是转义后的字符。这个内容不能直接用于 Vue 等模板的展示，也不能直接用于内容长度计算。不能用于标题、alert 等 <br/>

可以看到，过滤并非可靠的，下面就要通过防止浏览器执行恶意代码：
1. 在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。
2. 如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患
3. DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，<a> 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。

<!-- 链接内包含恶意代码 -->
< a href=" ">1</ a>
 <script>
// setTimeout()/setInterval() 中调用恶意代码
setTimeout("UNTRUSTED")
setInterval("UNTRUSTED")
 
// location 调用恶意代码
location.href = 'UNTRUSTED'
 
// eval() 中调用恶意代码
eval("UNTRUSTED")
```

## CSRF（Cross-site request forgery）跨站请求伪造
攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。
利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

### CSRF攻击
1. 害者登录a.com，并保留了登录凭证（Cookie）
2. 攻击者引诱受害者访问了b.com
3. b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带a.com的Cookie
4. a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求
5. a.com以受害者的名义执行了act=xx
    攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作
```
举例：
CSRF 可以通过get请求，即通过访问img的页面后，浏览器自动访问目标地址，发送请求。
同样，也可以设置一个自动提交的表单发送post请求，如下：
<form action="http://bank.example/withdraw" method=POST>
    <input type="hidden" name="account" value="xiaoming" />
    <input type="hidden" name="amount" value="10000" />
    <input type="hidden" name="for" value="hacker" />
</form>
<script> document.forms[0].submit(); </script> 
访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。
还有一种为使用a标签的，需要用户点击链接才会触发。
访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。
< a href="http://test.com/csrf/withdraw.php?amount=1000&for=hacker" taget="_blank">
    重磅消息！！
<a/>
```

### CSRF特点
1. 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。
2. 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；在服务器端直接改变数据的值，而不是直接窃取数据。
3. 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。
4. 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。
   
### CSRF预防
1. 尽量使用 post 请求
2. 加入验证码（这样能确保是用户行为而不是黑客行为）
3. 验证 referer：
    a. referer 是 header的一部分
    b. referer 会告诉我们请求从哪一个网页发来的，黑客伪装用户只能从自己的网站发出请求，对比refere r如果 referer 不一致就拒绝请求
4. Anti CSRF Token
    a. 在from表单或头信息传递一个随机token
    b. token传递在服务端
    c. 服务端通过拦截器验证有效性
    d. 验证失败拒绝请求

## SQL注入攻击
通过将恶意的 Sql查询或添加语句插入到应用的输入参数中，再在后台 Sql服务器上解析执行进行的攻击。

### SQL注入
1. 找出SQL漏洞的注入点
2. 判断数据库的类型以及版本
3. 猜解用户名和密码
4. 利用工具查找Web后台管理入口
5. 入侵和破坏

```
举例：
String sql = "SELECT * FROM t_user WHERE username='"+userName+"' AND pwd='"+password+"'"; 

密码输入: ' OR '1'='1时，结果如下：
SELECT * FROM t_user WHERE username='xxx' AND pwd='' OR '1'='1'

此时，等同于不需要密码
```

### SQL防御
1. 严格检查输入变量的类型和格式
2. 过滤和转义特殊字符
3. 对访问数据库的Web应用程序采用Web应用防火墙

```
1. 使用预编译处理输入参数：要防御 SQL 注入，用户的输入就不能直接嵌套在 SQL 语句当中。使用参数化的语句，用户的输入就被限制于一个参数当中， 比如用prepareStatement，则需要在SQL中使用#{}少使用${}
2. 输入验证：检查用户输入的合法性，以确保输入的内容为正常的数据。数据检查应当在客户端和服务器端都执行，之所以要执行服务器端验证，是因为客户端的校验往往只是减轻服务器的压力和提高对用户的友好度，攻击者完全有可能通过抓包修改参数或者是获得网页的源代码后，修改验证合法性的脚本（或者直接删除脚本），然后将非法内容通过修改后的表单提交给服务器等等手段绕过客户端的校验。因此，要保证验证操作确实已经执行，唯一的办法就是在服务器端也执行验证。但是这些方法很容易出现由于过滤不严导致恶意攻击者可能绕过这些过滤的现象，需要慎重使用。
3. 错误消息处理：防范 SQL 注入，还要避免出现一些详细的错误消息，恶意攻击者往往会利用这些报错信息来判断后台 SQL 的拼接形式，甚至是直接利用这些报错注入将数据库中的数据通过报错信息显示出来。
4. 加密处理：将用户登录名称、密码等数据加密保存。加密用户输入的数据，然后再将它与数据库中保存的数据比较，这相当于对用户输入的数据进行了“消毒”处理，用户输入的数据不再对数据库有任何特殊的意义，从而也就防止了攻击者注入 SQL 命令。
```

# 三、其他方式

##### 命令注入
Web应用未对用户提交的数据做过滤或者转义，导致服务器端执行了黑客提交的命令。黑客利用登入注入攻击，可以对服务器植入后门、直接反弹shell入侵服务器。

##### 目录遍历
Web应用对相关目录未做访问权限控制，并且未对用户提交的数据做过滤或者转义，导致服务器敏感文件泄露。黑客利用目录遍历攻击，可获取服务器的配置文件，进而入侵服务器。

##### 本地文件包含
Web应用对相关目录未做访问权限控制，并且未对用户提交的数据做过滤或者转义，导致服务器敏感文件泄露。黑客利用本地文件包含漏洞，可以获取服务器敏感文件、植入webshell入侵服务器。

##### 远程文件包含
Web应用未对用户提交的文件名做过滤或者转义，导致引入远程的恶意文件。黑客利用远程文件包含漏洞，可以加载远程的恶意文件，导致恶意代码执行、获取服务器的权限。

##### 木马后门
Web应用未对用户提交的数据做过滤或者转义，导致木马代码执行。黑客利用木马后门攻击，可以入侵服务器。

##### 缓冲区溢出
http协议未对请求头部做字节大小限制，导致可以提交大量数据因此可能导致恶意代码被执行。

##### 文件上传
Web应用未对文件名后缀，上传数据包是否合规，导致恶意文件上传。文件上传攻击，将包含恶意代码的文件上传到服务器，最终导致服务器被入侵。

##### 扫描器扫描
黑客利用漏洞扫描器扫描网站，可以发现web应用存在的漏洞，最终利用相关漏洞攻击网站。

##### 高级爬虫
爬虫自动化程度较高可以识别setcookie等简单的爬虫防护方式。

##### 常规爬虫
爬虫自动化程度较低，可以利用一些简单的防护算法识别,如setcookie的方式。

##### 敏感信息泄露
web应用过滤用户提交的数据导致应用程序抛出异常，泄露敏感信息，黑客可能利用泄露的敏感信息进一步攻击网站。

##### 服务器错误
Web应用配置错误，导致服务器报错从而泄露敏感信息，黑客可能利用泄露的敏感信息进一步攻击网站。

##### 非法文件下载
Web应用未对敏感文件(密码、配置、备份、数据库等)访问做权限控制，导致敏感文件被下载，黑客利用下载的敏感文件可以进一步攻击网站。

##### 第三方组件漏洞
Web应用使用了存在漏洞的第三方组件，导致网站被攻击。

##### XPATH注入
Web应用在用xpath解析xml时未对用户提交的数据做过滤，导致恶意构造的语句被xpath执行。黑客利用xpath注入攻击，可以获取xml文档的重要信息。

##### XML注入
Web应用程序使用较早的或配置不佳的XML处理器解析了XML文档中的外部实体引用，导致服务器解析外部引入的xml实体。黑客利用xml注入攻击可以获取服务器敏感文件、端口扫描攻击、dos攻击。

##### LDAP注入防护
Web应用使用ldap协议访问目录，并且未对用户提交的数据做过滤或转义，导致服务端执行了恶意ldap语句，黑客利用ldap注入可获取用户信息、提升权限。

##### SSI注入
Web服务器配置了ssi，并且html中嵌入用户输入，导致服务器执行恶意的ssi命令。黑客利用ssi注入可以执行系统命令。

##### Webshell
黑客连接尝试去连接网站可能存在的webshell，黑客可能通过中国菜刀等工具去连接webshell入侵服务器。

##### 暴力破解
黑客在短时间内大量请求某一url尝试猜解网站用户名、密码等信息，黑客利用暴力破解攻击，猜解网站的用户名、密码，可以进一步攻击网站。

##### 非法请求方法
Web应用服务器配置允许put请求方法请求，黑客可以构造非法请求方式上传恶意文件入侵服务器。

##### 撞库
Web应用对用户登入功能没做验证码验证，黑客可以借助工具结合社工库去猜网站用户名及密码。

##### 固定会话
Web应用使用固定的cookie会话，导致cookie劫持。

##### IP黑名单
某一被确认为恶意ip，被waf拉黑后，所有请求都会被拦截

##### 动态IP黑名单
某一ip发送了较多攻击请求，会被waf自动拉黑一段时间，该时间段内所有的请求都被拦截。
